---
layout: articlead
title: FabricJS common gotchas
---
<div class="container" style="margin:30px auto">
<h1>FabricJS gotchas</h1>
<p>
This page contains a list of the most common issues opened by people approaching fabricJS for the first time.
Those pitfalls are caused both from the lack of clear explanations and non perfect docs.
Here we try to address the common issues.
</p>
<h3>Objects are no more selectable - setCoords</h3>
<p>
Fabric mantains 2 sets of coordinates to quickly know where an object is on the canvas. Those are linked to 2 objects properties, oCoords and aCoords.<br/>
Those coordinates are updated by fabricJS automatically when an user interact with objects corners or ends a transformation, a drag for example.
In all the other cases is the developer that has to call `Object.setCoords()` in order to have the object recognized in the rendered position.<br />
The most commmon Symptom is an object not being selectable. This happens after the dev changed by code the top/left or the scale or the canvas viewport.
After those operations, that same code should call `setCoords()` eventually on all objects.
</p>
<pre>
  function repositionRect(x, y) {
    rect.left = x;
    rect.top = y;
    rect.setCoords();
  }
</pre>
<h3>Wrong position after reloading a JSON object - NUM_FRACTION_DIGITS</h3>
<p>
Fabric can serialize and deserialize objects in a plain object format.<br />
When dealing with serialization, floats can be a problem and give long strings with an unnecessary quantity of decimals. This blows up the string size.<br />
To reduce that, there is a constant defined on the Object  called `NUM_FRACTION_DIGITS`, historically set to 2.
That means that a top value of `3.454534413123` is saved as `3.45`, same for scale, width, height. This is mostly fine unless you are dealing without
situation where precision matter.<br />
To make an example, a very large image, can be scaled down to a small size using a scale of `0.0151`.<br />
In this case a serialization would save it as `0.02` changing meaningully the scale.
If you are facing such situations, in your project set the constant higher:
`fabric.Object.NUM_FRACTION_DIGITS = 8` to have 8 decimals on properties.<br />
This affects SVG export too.
</p>

<h3>Objects misbehave when dealing with text input - numbers vs strings</h3>
<p>
Sometimes in prototypes and quick proof of concepts, people change fabric objects properties with text inputs.<br />
Fabric documentation states that top, left, scaleX, angle and other properties requires numbers as values.<br />
<strong>Text inputs return strings.</strong> FabricJS does not check types and does not convert them, when it does convert a string to a number is because
of a side effect of some code and is not a feature to rely on.<br />
Use parseInt and parseFloat before assigning a value to a property that requires a number.
</p>

<h3>Object does not update after changing property - objectCaching</h3>
<p>
A common source of confusion is when a developer assigns a new property to fill and the objects does not update after a renderAll.<br />
FabricJS does cache objects as images to speed up rendering. If you want fabricJS to know that something changed and that a particular object
needs to be redrawn, use the `set` method.
</p>
<pre>
  rect.set('fill', 'red');
  canvas.requestRenderAll();
</pre>
<p> or, as an alternative:</p>
<pre>
  rect.fill = 'red';
  rect.stroke = 'blue';
  rect.set('dirty', true);
</pre>
<p> For more information and detailed explanation, check the <a href="/fabric-object-caching">dedicated caching page</a>.</p>
<h3>Objects have a transparent stroke of width 1 by default</h3>

By default, objects have a transparent stroke of width 1 that shift them by 0.5 pixel horizontally and vertically.
This will make hard for you to position objects at exact position.
There are a couple of reason for this:
 - if it had no strokeWidth, setting stroke color would bring no results
 - SVG have the same default so for svg import it made sense to do so
 - Before fabric v1.5 stroke wasn't part of the control bounding box and position so this wasn't an issue.

To remove the stroke:
<pre>
rect.set('strokeWidth', 0);
</pre>
<h3>Blurry (Nested/Custom) Objects - reference canvas for retinaScaling</h3>

<p>
All objects need a reference to <code>fabric.Canvas</code> for proper rendering. 
Without the reference objects can't access the retina scaling value (<a target="_blank" href="https://developer.mozilla.org/en-US/docs/Web/API/Window/devicePixelRatio#correcting_resolution_in_a_canvas">device pixel ratio</a>), resulting in bad resolution.
This usually happens when an object is a child of another object. Fix it by adding a referencing to canvas in the parent's <code>_set</code> method.<br />
Now that the object renders nicely we may encounter another <strong>gotcha</strong>. The <a href="#nested_objects">Nested Objects gotcha</a>.
</p>

To reference canvas:
<pre>
fabric.MyCustomObject = fabric.util.createClass(fabric.Object, {
  _set(key, value){
    // this is a good place to pass down options to children
    this.callSuper('_set', key, value);
    //  set canvas on nested object
    key === 'canvas' && this._nestedObject._set(key, value);
  }
});
</pre>
<h3 id="nested_objects">Nested Objects - transform matrix relative to canvas</h3>

<p>
Creating custom objects built from other objects is an extremely powerful option, but it takes you closer to fabric's edge.<br/>
You may experience problems. Let's use an example to explain.<br />
When an object (a) renders, it transforms the rendering context to it's center point.
In order to render another object (b) as a child of (a) we need to take that into account.
We can handle (b)'s transform matrix relative to (a)'s center point. This will render (b) correctly.<br />
However, it will cause many problems.<br />
Let's take, for example, one of the simplest and most powerful rendering optimizations to explain.<br />
Before an object renders it checks if it's visible on screen. If it isn't it skips the rendering process.
Checking if it's visible means the object checks it's transform matrix relative to the canvas.
But we've handled it's transform matrix relative to (a)....<br />
This will cause (b) to skip renders in some cases and not show at all.<br />
This gotcha affects almost everything fabric has to offer.<br />
The solution is simple.<br />
Handle the transform matrix relative to canvas, <strong>ALWAYS</strong>. When rendering (b), transform the rendering context from (a)'s center point back to canvas.<br />
For more information and detailed explanation, check the dedicated pages: <a href="/using-transformations">Using transformations</a>, <a href="/fabric-intro-part-3#subclassing">Subclassing</a>.

</p>

Creating class (a) and rendering (b):
<pre>
fabric.a = fabric.util.createClass(fabric.Object, {
  /**
  *
  * @param {CanvasRenderingContext2D} ctx
  */
  render: function (ctx) {
    ctx.save();
    // reverse (a) transform on ctx, making it relative to canvas
    ctx.transform.apply(ctx, fabric.util.invertTransform(this.calcTransformMatrix()));
    b.render(ctx);
    ctx.restore();
  }
});
</pre>
</div>
